Object subclass: #RsrObject	instanceVariableNames: 'rsrName rsrSerialNumber'	classVariableNames: ''	poolDictionaries: ''	category: 'RemoteServicesReplication'!!RsrObject commentStamp: '<historical>' prior: 0!Base class for an Object that will be replicated across smalltalk processes.!!RsrObject methodsFor: 'updating' stamp: 'AaronBlakeman 11/10/2017 14:40'!rsrUpdate"Informs the RsrService that changes have been made and the object must be propagated."|rsr oldSerial|rsr := RsrService uniqueInstance.oldSerial := self rsrSerialNumber.rsrSerialNumber := self incrementAndReturnSerialNumber.rsr update: self! !!RsrObject methodsFor: 'accessing' stamp: 'AaronBlakeman 11/6/2017 10:04'!rsrName"Get a unique name for this instance."^rsrName	ifNil: [ rsrName := (self class printString), RsrService objectOffset printString ].! !!RsrObject methodsFor: 'accessing' stamp: 'AaronBlakeman 11/1/2017 15:36'!rsrSerialNumber^rsrSerialNumber 	ifNil: [ rsrSerialNumber := (DateAndTime now asNanoSeconds) + 		(RsrService objectOffset) ]! !!RsrObject methodsFor: 'testing' stamp: 'AaronBlakeman 11/10/2017 11:46'!isLocal|rsr |rsr  := RsrService uniqueInstance.rsr localObjects keysDo:   	[ :key |		key = self rsrName 			ifTrue: [ ^true ] ].^false! !!RsrObject methodsFor: 'testing' stamp: 'AaronBlakeman 11/13/2017 10:15'!isRemote|rsr |rsr  := RsrService uniqueInstance.rsr remoteObjects keysDo:   	[ :key |		key = self rsrName 			ifTrue: [ ^true ] ].^false! !!RsrObject methodsFor: 'as yet unclassified' stamp: 'AaronBlakeman 11/1/2017 15:41'!incrementAndReturnSerialNumberrsrSerialNumber := rsrSerialNumber +1.^rsrSerialNumber! !!RsrObject methodsFor: 'tools registry' stamp: 'AaronBlakeman 11/10/2017 14:37'!rsrRegister|rsr|rsr := RsrService uniqueInstance.rsr addLocalObject: self.! !Object subclass: #RsrService	instanceVariableNames: 'localObjects remoteObjects localSerialNumbers remoteSerialNumbers port timeout session backlogSize observers debug process'	classVariableNames: ''	poolDictionaries: ''	category: 'RemoteServicesReplication'!!RsrService commentStamp: '<historical>' prior: 0!Root service object for keeping track of the locally defined objects to be replicated and service manager for maintaining state of remote connections.!!RsrService methodsFor: 'request handling' stamp: 'AaronBlakeman 11/13/2017 15:06'!listenLoop	| socket stream data results|	socket := Socket newTCP.		"Need to verify that binding to the specific port actually worked."	socket listenOn: port backlogSize: self backlogSize.	session := socket waitForAcceptFor: self timeout.	session ifNotNil: [		data := session receiveData.		"Need to validate the object before trying to use it."		stream := STONReader on: data readStream. 		results := stream next.		self processReceivedObject: results.	].	socket closeAndDestroy. ! !!RsrService methodsFor: 'request handling' stamp: 'AaronBlakeman 11/9/2017 15:52'!sendTo: address port: aPort object: anObject 	|host socket serializedObject|	socket := Socket newTCP.	host := NetNameResolver addressForName: address.	serializedObject := STON toString: anObject.	[ socket		connectTo: host port: aPort;		waitForConnectionFor: 10.		socket sendData: serializedObject. 	] ensure: [ socket closeAndDestroy  ].! !!RsrService methodsFor: 'request handling' stamp: 'AaronBlakeman 11/10/2017 11:44'!processReceivedObject: anObjectTranscript show: anObject ; cr.(anObject isKindOf: RsrServiceProxy  ) 	ifTrue: [ self addObserver: anObject hostname port: anObject port]	ifFalse: [  anObject isLocal						ifFalse: [ self addRemoteObject: anObject]						"Need to check serial numbers here."						ifTrue:  [ self localObjects at: anObject rsrName put: anObject]				].	! !!RsrService methodsFor: 'request handling' stamp: 'AaronBlakeman 11/9/2017 17:10'!processRemoteChange: anRsrObjectobservers associationsDo:  [ :entry | self sendTo: entry key port: entry value object: anRsrObject   ]! !!RsrService methodsFor: 'accessing' stamp: 'AaronBlakeman 11/6/2017 13:42'!timeout: aNewTimeout	timeout := aNewTimeout! !!RsrService methodsFor: 'accessing' stamp: 'AaronBlakeman 11/10/2017 08:28'!getRemoteObject: name^remoteObjects at: name ! !!RsrService methodsFor: 'accessing' stamp: 'AaronBlakeman 11/9/2017 16:47'!timeout^timeout		ifNil: [ timeout := 600  ].	! !!RsrService methodsFor: 'accessing' stamp: 'AaronBlakeman 11/6/2017 13:43'!backlogSize: size	backlogSize := size! !!RsrService methodsFor: 'accessing' stamp: 'AaronBlakeman 11/6/2017 13:27'!localSerialNumbers| serialNumbers  |serialNumbers  := OrderedCollection new.localObjects valuesDo: [ :element | serialNumbers add: element  ].^serialNumbers  ! !!RsrService methodsFor: 'accessing' stamp: 'AaronBlakeman 11/9/2017 16:46'!backlogSize^backlogSize 		ifNil: [ backlogSize  := 10  ].	! !!RsrService methodsFor: 'accessing' stamp: 'AaronBlakeman 11/14/2017 13:54'!getObject: objectNamelocalObjects keysDo: [ :key | 	key = objectName ifTrue: [ 		|o|		o := localObjects at: objectName.		^o ifNil: [ 			"The object has been garbage collected."			^Error signal: 'Object no longer exists.'		 ]				 ]].^remoteObjects at: objectName.! !!RsrService methodsFor: 'accessing' stamp: 'AaronBlakeman 11/14/2017 14:15'!start	process := [ [ self listenLoop ] repeat ]		forkAt: Processor highIOPriority.	Transcript clear ; show: 'Server started' ; cr.! !!RsrService methodsFor: 'accessing' stamp: 'AaronBlakeman 11/6/2017 13:42'!port: newPort	port := newPort.	! !!RsrService methodsFor: 'accessing' stamp: 'AaronBlakeman 11/2/2017 15:12'!localObjects^localObjects ! !!RsrService methodsFor: 'accessing' stamp: 'AaronBlakeman 11/10/2017 10:09'!observe: hostname port: aPort|rsrProxy |rsrProxy  := RsrServiceProxy new.rsrProxy hostname: NetNameResolver localHostName.rsrProxy port: self port.self sendTo: hostname port: aPort object: rsrProxy.! !!RsrService methodsFor: 'accessing' stamp: 'AaronBlakeman 11/10/2017 08:55'!update: anRsrObjectanRsrObject isLocal 	ifTrue: [ localObjects at: anRsrObject rsrName put: anRsrObject.	 ].self processRemoteChange: anRsrObject.! !!RsrService methodsFor: 'accessing' stamp: 'AaronBlakeman 11/6/2017 09:56'!numberOfLocalObjects	| count |	count := 0.	localObjects keysDo: [ :element | count := count + 1 ].	^ count! !!RsrService methodsFor: 'accessing' stamp: 'AaronBlakeman 11/10/2017 10:40'!getLocalObject: name^localObjects at: name ! !!RsrService methodsFor: 'accessing' stamp: 'AaronBlakeman 11/9/2017 16:45'!port^port 	ifNil: [ port := 8080].! !!RsrService methodsFor: 'accessing' stamp: 'AaronBlakeman 11/7/2017 16:46'!remoteObjects^remoteObjects ! !!RsrService methodsFor: 'accessing' stamp: 'AaronBlakeman 11/14/2017 14:15'!stop	process terminate. 	process := nil.! !!RsrService methodsFor: 'initialization' stamp: 'AaronBlakeman 11/14/2017 13:28'!initialize	super initialize.	localObjects := WeakValueDictionary new.	localSerialNumbers := Dictionary new.	remoteObjects := Dictionary new.	remoteSerialNumbers := Dictionary new.	observers := Dictionary new.	self port.	self timeout.	self backlogSize.		debug := true.	! !!RsrService methodsFor: 'private' stamp: 'AaronBlakeman 11/1/2017 15:22'!removeAllLocalObjectslocalObjects := nil! !!RsrService methodsFor: 'adding' stamp: 'AaronBlakeman 11/7/2017 16:46'!addRemoteObject: anRsrObjectremoteObjects at: anRsrObject rsrName put: anRsrObject .! !!RsrService methodsFor: 'adding' stamp: 'AaronBlakeman 11/14/2017 13:21'!addObserver: hostnameobservers at: hostname put: self port.! !!RsrService methodsFor: 'adding' stamp: 'AaronBlakeman 11/9/2017 16:40'!addObserver: hostname port: aPortobservers at: hostname put: aPort.! !!RsrService methodsFor: 'adding' stamp: 'AaronBlakeman 11/6/2017 13:25'!addLocalObject: anRsrObjectlocalObjects at: anRsrObject rsrName put: anRsrObject .! !!RsrService methodsFor: 'removing' stamp: 'AaronBlakeman 11/10/2017 14:46'!removeObserver: hostnameobservers removeKey: hostname.! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!RsrService class	instanceVariableNames: 'uniqueInstance objectOffset'!!RsrService class methodsFor: 'accessing' stamp: 'AaronBlakeman 11/2/2017 15:13'!uniqueInstance^ uniqueInstance 	ifNil: [ 		uniqueInstance := self basicNew initialize.		]! !!RsrService class methodsFor: 'accessing' stamp: 'AaronBlakeman 11/1/2017 15:38'!objectOffset^objectOffset	ifNil: [ objectOffset := 0. ]	ifNotNil: [ objectOffset := objectOffset + 1. ]! !!RsrService class methodsFor: 'instance creation' stamp: 'AaronBlakeman 10/31/2017 14:10'!new	self error: 'This class is a singleton.  Send uniqueInstance instead'! !!RsrService class methodsFor: 'private' stamp: 'AaronBlakeman 11/14/2017 14:18'!resetuniqueInstance stop.uniqueInstance := nil.! !Object subclass: #RsrServiceProxy	instanceVariableNames: 'hostname port'	classVariableNames: ''	poolDictionaries: ''	category: 'RemoteServicesReplication'!!RsrServiceProxy commentStamp: 'AaronBlakeman 11/9/2017 16:05' prior: 0!I represent a proxy class used for communications over the wire.!!RsrServiceProxy methodsFor: 'accessing' stamp: 'AaronBlakeman 11/9/2017 16:04'!hostname^hostname! !!RsrServiceProxy methodsFor: 'accessing' stamp: 'AaronBlakeman 11/9/2017 16:05'!hostname: aHostnamehostname := aHostname! !!RsrServiceProxy methodsFor: 'accessing' stamp: 'AaronBlakeman 11/9/2017 16:05'!port: aPortport := aPort! !!RsrServiceProxy methodsFor: 'accessing' stamp: 'AaronBlakeman 11/9/2017 16:05'!port^port! !