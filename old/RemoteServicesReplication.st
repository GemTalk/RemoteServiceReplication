Object subclass: #RsrBroker	instanceVariableNames: 'rsrServer'	classVariableNames: ''	poolDictionaries: ''	category: 'RemoteServicesReplication'!!RsrBroker commentStamp: 'AaronBlakeman 12/8/2017 09:22' prior: 0!I mediate the flow of objects between clients and RsrServices!!RsrBroker methodsFor: 'receiving' stamp: 'AaronBlakeman 12/18/2017 15:49'!processReceivedObject: anObject	"This method receives an object over the wire and processes it based on it's type."	(anObject isKindOf: RsrGcProxy) 		ifTrue: [ |rr|			rr := RsrRegistry uniqueInstance.			rr cleanup.		].		! !!RsrBroker methodsFor: 'receiving' stamp: 'AaronBlakeman 12/8/2017 10:37'!receive: data	  | stream results |	  stream := STONReader on: data readStream. 	  results := stream next.	  self processReceivedObject: results.! !!RsrBroker methodsFor: 'sending' stamp: 'AaronBlakeman 12/8/2017 10:36'!prepare: anObject.	^STON toString: anObject.! !Object subclass: #RsrDaemon	instanceVariableNames: 'port timeout backlogSize debug process connectionSocket isRunning isRunningLock remoteRsrServer'	classVariableNames: ''	poolDictionaries: ''	category: 'RemoteServicesReplication'!!RsrDaemon commentStamp: 'AaronBlakeman 12/6/2017 09:24' prior: 0!I am the daemon that manages connections between Rsr systems.!!RsrDaemon methodsFor: 'as yet unclassified' stamp: 'AaronBlakeman 12/8/2017 10:35'!send: anObject to: aRsrServer	|host socket objectToSend address rsrBroker|	rsrBroker := RsrBroker new.	address := aRsrServer hostname.	port := aRsrServer port.	socket := Socket newTCP.	host := NetNameResolver addressForName: address.	objectToSend  := rsrBroker prepare: anObject.	[ socket		connectTo: host port: port;		waitForConnectionFor: 10.		socket sendData: objectToSend. 	] ensure: [ socket closeAndDestroy  ].	! !!RsrDaemon methodsFor: 'initialization' stamp: 'AaronBlakeman 12/14/2017 13:10'!initialize	super initialize.	isRunningLock  := Mutex new.	self isRunning: false.	debug := true.	! !!RsrDaemon methodsFor: 'testing' stamp: 'AaronBlakeman 12/6/2017 09:26'!isRunning	^ isRunningLock critical: [ isRunning  ]! !!RsrDaemon methodsFor: 'accessing' stamp: 'AaronBlakeman 12/6/2017 09:30'!listenLoop	[[isRunning] 		whileTrue: [ self handleConnection ]]		ensure: [ connectionSocket closeAndDestroy. ]		! !!RsrDaemon methodsFor: 'accessing' stamp: 'AaronBlakeman 12/8/2017 10:03'!send: anObject 	^self send: anObject to: self remoteServerName.	! !!RsrDaemon methodsFor: 'accessing' stamp: 'AaronBlakeman 12/6/2017 09:27'!isRunning: aBoolean	isRunningLock critical: [ isRunning := aBoolean  ].! !!RsrDaemon methodsFor: 'accessing' stamp: 'AaronBlakeman 12/6/2017 09:26'!start	isRunningLock critical: [ 		self isRunning ifTrue: [ ^self ].		self isRunning: true].		connectionSocket := Socket newTCP.	connectionSocket 		listenOn: self port 		backlogSize: self backlogSize.	   [ self listenLoop ]  fork.	self debug 		ifTrue: [Transcript clear ; show: 'Server started' ; cr].	! !!RsrDaemon methodsFor: 'accessing' stamp: 'AaronBlakeman 12/18/2017 09:00'!remoteServerName	^remoteRsrServer.! !!RsrDaemon methodsFor: 'accessing' stamp: 'AaronBlakeman 12/8/2017 10:02'!remoteServerName: aServerName	|aRsrServer|		aRsrServer := RsrServer new.	aRsrServer hostname: aServerName.	remoteRsrServer := aRsrServer.! !!RsrDaemon methodsFor: 'accessing' stamp: 'AaronBlakeman 12/8/2017 11:46'!receiveDataUsing: aSocket	|data rsrBroker|	rsrBroker := RsrBroker new.	[ data := aSocket receiveDataTimeout: self timeout.	  rsrBroker receive: data.	] ensure: [ 	  aSocket closeAndDestroy. ].	! !!RsrDaemon methodsFor: 'accessing' stamp: 'AaronBlakeman 12/6/2017 09:32'!stop	self isRunning: false.	connectionSocket closeAndDestroy.! !!RsrDaemon methodsFor: 'accessing' stamp: 'AaronBlakeman 12/8/2017 10:06'!handleConnection	|interactionSocket|	interactionSocket := connectionSocket 									waitForAcceptFor: (self timeout) 									ifTimedOut: [ ^self ].	[  self receiveDataUsing: interactionSocket ] fork.! !!RsrDaemon methodsFor: 'definition' stamp: 'AaronBlakeman 12/6/2017 09:31'!timeout: aNewTimeout	timeout := aNewTimeout! !!RsrDaemon methodsFor: 'definition' stamp: 'AaronBlakeman 12/6/2017 09:29'!backlogSize	^backlogSize 			ifNil: [ backlogSize  := 100  ].! !!RsrDaemon methodsFor: 'definition' stamp: 'AaronBlakeman 12/6/2017 09:32'!debug	^debug! !!RsrDaemon methodsFor: 'definition' stamp: 'AaronBlakeman 12/6/2017 09:31'!timeout	^timeout		ifNil: [ timeout := 600  ].	! !!RsrDaemon methodsFor: 'definition' stamp: 'AaronBlakeman 12/6/2017 09:29'!backlogSize: size	backlogSize := size! !!RsrDaemon methodsFor: 'definition' stamp: 'AaronBlakeman 12/6/2017 09:29'!port	^port 		ifNil: [ port := 8080].! !!RsrDaemon methodsFor: 'definition' stamp: 'AaronBlakeman 12/6/2017 09:29'!port: newPort	port := newPort.! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!RsrDaemon class	instanceVariableNames: 'uniqueInstance objectOffset'!!RsrDaemon class methodsFor: 'instance creation' stamp: 'AaronBlakeman 12/7/2017 16:20'!objectOffset	^objectOffset		ifNil: [ objectOffset := 0. ]		ifNotNil: [ objectOffset := objectOffset + 1. ]	! !!RsrDaemon class methodsFor: 'instance creation' stamp: 'AaronBlakeman 12/7/2017 16:20'!uniqueInstance	^ uniqueInstance 		ifNil: [ uniqueInstance := self basicNew initialize.]! !!RsrDaemon class methodsFor: 'instance creation' stamp: 'AaronBlakeman 12/6/2017 09:34'!new	self error: 'This class is a singleton.  Send uniqueInstance instead'! !Object subclass: #RsrGcProxy	instanceVariableNames: 'entriesToClean'	classVariableNames: ''	poolDictionaries: ''	category: 'RemoteServicesReplication'!!RsrGcProxy commentStamp: 'AaronBlakeman 12/8/2017 15:26' prior: 0!I transport the names of the deceased so that they may be properly disposed of.!!RsrGcProxy methodsFor: 'as yet unclassified' stamp: 'AaronBlakeman 12/8/2017 15:26'!objectsToClean: aLinkedList	entriesToClean := aLinkedList! !!RsrGcProxy methodsFor: 'as yet unclassified' stamp: 'AaronBlakeman 12/8/2017 15:26'!objectsToClean	^entriesToClean		ifNil: [ ^LinkedList new. ]! !Object subclass: #RsrObject	instanceVariableNames: 'rsrName representedObject rsrSerialNumber'	classVariableNames: ''	poolDictionaries: ''	category: 'RemoteServicesReplication'!!RsrObject commentStamp: 'AaronBlakeman 12/8/2017 12:17' prior: 0!I represent an object that's being managed by Rsr.!!RsrObject methodsFor: 'identity' stamp: 'AaronBlakeman 12/15/2017 11:35'!rsrName	^ rsrName 		ifNil: [ rsrName := representedObject class printString, RsrRegistry objectOffset printString. ]! !!RsrObject methodsFor: 'identity' stamp: 'AaronBlakeman 12/8/2017 15:19'!rsrSerialNumber	^rsrSerialNumber 		ifNil: [ rsrSerialNumber := (DateAndTime now asNanoSeconds) + 			(RsrRegistry objectOffset) ]! !!RsrObject methodsFor: 'instance creation' stamp: 'AaronBlakeman 12/8/2017 15:39'!finalize	|rsr|	rsr := RsrRegistry uniqueInstance.	rsr cleanup.	Transcript show: self rsrName ;show: ' finalized.' ; cr.! !!RsrObject methodsFor: 'instance creation' stamp: 'AaronBlakeman 12/8/2017 15:35'!put: anObject 	representedObject := anObject.	self rsrName.	self rsrSerialNumber.	"When this object gets GC'd we need to clean up remote references to it"	self class finalizationRegistry add: self.! !!RsrObject methodsFor: 'initialization' stamp: 'AaronBlakeman 12/18/2017 16:34'!getObject: anObjectName	| rsrRegistry |	rsrRegistry := RsrRegistry uniqueInstance.	representedObject := rsrRegistry getObject: anObjectName! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!RsrObject class	instanceVariableNames: ''!!RsrObject class methodsFor: 'instance creation' stamp: 'AaronBlakeman 12/14/2017 14:27'!wrap: anObject	|rsr|	rsr := RsrObject new.	rsr put: anObject.	^rsr! !RsrObject subclass: #RsrInspector	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'RemoteServicesReplication'!!RsrInspector commentStamp: 'AaronBlakeman 12/11/2017 15:45' prior: 0!I represent a base inspector service client.!"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!RsrInspector class	instanceVariableNames: ''!!RsrInspector class methodsFor: 'actions' stamp: 'AaronBlakeman 12/18/2017 16:34'!inspect: anObject	| rsrInspectorClient |	"If the user sent a String, then the object to be inspected lives on the other end of the connection."	(anObject isKindOf: String)		ifTrue: [ rsrInspectorClient := RsrInspectorClient new.			rsrInspectorClient getObject: anObject ]		ifFalse: [  ].	^ rsrInspectorClient! !RsrInspector subclass: #RsrInspectorClient	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'RemoteServicesReplication'!!RsrInspectorClient commentStamp: 'AaronBlakeman 12/11/2017 15:45' prior: 0!I represent an inspector client.!RsrInspector subclass: #RsrInspectorServer	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'RemoteServicesReplication'!!RsrInspectorServer commentStamp: 'AaronBlakeman 12/11/2017 15:45' prior: 0!I represent an inspector client.!RsrObject subclass: #RsrReference	instanceVariableNames: ''	classVariableNames: ''	poolDictionaries: ''	category: 'RemoteServicesReplication'!!RsrReference commentStamp: 'AaronBlakeman 12/15/2017 11:29' prior: 0!I represent and object that can safely be sent over the wire.!!RsrReference methodsFor: 'instance creation' stamp: 'AaronBlakeman 12/18/2017 15:51'!put: anObject	"This should get more details about the represented object.  EG. instVars."	representedObject := anObject.! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!RsrReference class	instanceVariableNames: ''!!RsrReference class methodsFor: 'instance creation' stamp: 'AaronBlakeman 12/18/2017 15:50'!getReference: anObject	| rsr |	rsr := RsrReference new.	rsr put: anObject.	^ rsr! !!RsrReference class methodsFor: 'instance creation' stamp: 'AaronBlakeman 12/18/2017 15:51'!wrap: anObject	"getReference shouldbe used instead of this."	^RsrReference getReference: anObject.	! !Object subclass: #RsrRegistry	instanceVariableNames: 'managedObjects'	classVariableNames: ''	poolDictionaries: ''	category: 'RemoteServicesReplication'!!RsrRegistry commentStamp: 'AaronBlakeman 12/8/2017 12:02' prior: 0!I maintain the associations between locally stored objects and their remote counterparts.!!RsrRegistry methodsFor: 'removing' stamp: 'AaronBlakeman 12/15/2017 11:45'!removeAllLocalObjects	managedObjects  := nil.	self managedObjects.! !!RsrRegistry methodsFor: 'initialization' stamp: 'AaronBlakeman 12/14/2017 13:17'!managedObjects	^managedObjects 		ifNil: [ managedObjects := Dictionary new ]! !!RsrRegistry methodsFor: 'initialization' stamp: 'AaronBlakeman 12/18/2017 16:30'!getObject: rsrObjectName	^ managedObjects at: rsrObjectName 		ifAbsent: [  ]! !!RsrRegistry methodsFor: 'initialization' stamp: 'AaronBlakeman 12/14/2017 14:36'!addObject: anRsrObject	managedObjects    		ifNil: [ self managedObjects ].	managedObjects at: anRsrObject rsrName put: anRsrObject.	! !!RsrRegistry methodsFor: 'initialization' stamp: 'AaronBlakeman 12/15/2017 11:47'!initialize	super initialize.	self managedObjects.	! !!RsrRegistry methodsFor: 'accessing' stamp: 'AaronBlakeman 12/14/2017 13:19'!findOrphanedKeys	|entriesToClean|	entriesToClean := LinkedList new.	managedObjects  		ifNotNil: [ 			managedObjects ifNotEmpty: [ 				managedObjects  keysDo: [ :key |					(managedObjects at: key )							ifNil: [ entriesToClean add: key.]					 ].			]		].	^entriesToClean! !!RsrRegistry methodsFor: 'accessing' stamp: 'AaronBlakeman 12/14/2017 13:18'!cleanup	[ |orphans| 		orphans := self findOrphanedKeys.		self cleanupManagedObjects: orphans.	] fork. "Don't want finalization to hang, so fork this and return.... though not sure that this is true"! !!RsrRegistry methodsFor: 'accessing' stamp: 'AaronBlakeman 12/15/2017 09:45'!cleanupManagedObjects: orphanedKeys    orphanedKeys do: [ :entry |        (managedObjects at: entry )            ifNil: [ managedObjects removeKey: entry].        managedObjects removeKey: entry.     ].! !"-- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- -- "!RsrRegistry class	instanceVariableNames: 'uniqueInstance objectOffset'!!RsrRegistry class methodsFor: 'instance creation' stamp: 'AaronBlakeman 12/8/2017 12:13'!uniqueInstance	^ uniqueInstance 		ifNil: [ uniqueInstance := self basicNew initialize. ]! !!RsrRegistry class methodsFor: 'instance creation' stamp: 'AaronBlakeman 12/8/2017 12:12'!new	self error: 'This class is a singleton.  Send uniqueInstance instead'! !!RsrRegistry class methodsFor: 'accessing' stamp: 'AaronBlakeman 12/8/2017 15:18'!objectOffset	^objectOffset		ifNil: [ objectOffset := 0. ]		ifNotNil: [ objectOffset := objectOffset + 1. ]! !Object subclass: #RsrServer	instanceVariableNames: 'hostname port'	classVariableNames: ''	poolDictionaries: ''	category: 'RemoteServicesReplication'!!RsrServer commentStamp: 'AaronBlakeman 12/8/2017 09:32' prior: 0!I represent an RsrServer!!RsrServer methodsFor: 'accessing' stamp: 'AaronBlakeman 12/8/2017 09:34'!defaultPort	^8080! !!RsrServer methodsFor: 'accessing' stamp: 'AaronBlakeman 12/8/2017 09:33'!hostname: serverName	hostname := serverName! !!RsrServer methodsFor: 'accessing' stamp: 'AaronBlakeman 12/8/2017 09:34'!port	^port 		ifNil: [ port := self defaultPort ].! !!RsrServer methodsFor: 'accessing' stamp: 'AaronBlakeman 12/8/2017 09:34'!port: aPort	port := aPort! !!RsrServer methodsFor: 'accessing' stamp: 'AaronBlakeman 12/8/2017 09:33'!hostname	^ hostname! !